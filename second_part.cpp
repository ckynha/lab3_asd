#include "second_part.h"

int DynamicProgrammingSolution::calculateBest() 
{
    d_.assign(n_, vector<int>(n_, 0));
    for (int i = 0; i < n_; ++i) // создаем квадратную матрицу
    {
        d_[i][i] = x_[i]; // присваиваем, т.к. максимальное значение для подстроки длиной 1 равно значению этого элемента
    }
    for (int len = 2; len <= n_; ++len) // проходимся по  всем возможным длинам подстрок
    {
        for (int i = 0; i <= n_ - len; ++i) // проходим по всем возможным начальным индексам i таким образом, чтобы подстрока x_[i..i+len-1] имела длину len
        {
            int j = i + len - 1;
            for (int k = i; k < j; ++k) // находим наибольшее значение, которое можно получить из каждой подстроки x_[i..i+len-1]
            {
                d_[i][j] = max(d_[i][j], max(d_[i][k] * d_[k + 1][j], d_[i][k] + d_[k + 1][j]));
                // 1. d_[i][k] * d_[k+1][j] - максимальное значение, которое можно получить путем умножения наибольшего значения подстроки x_[i..k] на наибольшее значение подстроки x_[k+1..j]
                // 2. d_[i][k] + d_[k+1][j] - максимальное значение, которое можно получить путем сложения наибольшего значения подстроки x_[i..k] и наибольшего значения подстроки x_[k+1..j]
                // 3. Текущее значение d_[i][j] - значение, которое уже может быть сохранено в матрице, если было рассчитано на предыдущих итерациях
            }
        }
    }
    calculated_ = true;
    return d_[0][n_ - 1];
}

int DynamicProgrammingSolution::answerForSegment(int i, int j)
{
    if (!calculated_)
    {
        cerr << "Matrix d_ is not calculated" << endl;
        return -1;
    }
    return d_[i][j];
}